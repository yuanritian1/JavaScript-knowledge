<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>

</html>
<script>
  // function throttle(fn, delay) {
  //   var timer;
  //   return function () {
  //     var _this = this;
  //     var args = arguments;
  //     if (timer) {
  //       return;
  //     }
  //     timer = setTimeout(function () {
  //       fn.apply(_this, args);
  //       timer = null; // 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器
  //     }, delay)
  //   }
  // }
  // function testThrottle(e, content) {
  //   console.log(e, content);
  // }
  // var testThrottleFn = throttle(testThrottle, 1000); // 节流函数
  // document.onmousemove = function (e) {
  //   testThrottleFn(e, 'throttle'); // 给节流函数传参
  // }
  //根据函数节流的原理，我们也可以不依赖 setTimeout实现函数节流。时间戳实现节流函数：
  function throttle(fn, delay) {
    var previous = 0;
    // 使用闭包返回一个函数并且用到闭包函数外面的变量previous
    return function () {
      var _this = this;
      var args = arguments;
      var now = new Date();
      if (now - previous > delay) {
        fn.apply(_this, args);
        previous = now;
      }
    }
  }

  // test
  function testThrottle(e, content) {
    console.log(e, content);
  }
  var testThrottleFn = throttle(testThrottle, 1000); // 节流函数
  document.onmousemove = function (e) {
    testThrottleFn(e, 'throttle'); // 给节流函数传参
  }
</script>